#!/usr/bin/env ruby

if ARGV.include? '--help' or ARGV.include? '-h'
  puts "Usage: #{$PROGRAM_NAME} [--all]"
  puts ""
  puts "Performs leave-one-out cross-validation of the classifier."
  puts "By default, outputs results only for samples with ambiguous extensions."
  puts "If the --all flag is given, all samples and languages are considered."
  exit 0
end

require 'parallel'
require 'linguist'
include Linguist

$all = false
if ARGV[0] == '--all'
  $all = true
end

# Skip extensions with catch-all heuristic.
# Disabled with --all.
$skip_extensions = Set.new()
unless $all
  Heuristics.all.each do |h|
    rules = h.instance_variable_get(:@rules)
    if rules[-1]['pattern'].is_a? AlwaysMatch
      $skip_extensions |= Set.new(h.extensions)
    end
  end
end

$samples = []
db = {}
Samples.each do |sample|
  sample[:data] = File.read(sample[:path])
  sample[:pretrained] = Classifier.train! db, sample[:language], sample[:data]
  $samples << sample
end
$global_vocab = db['vocabulary'].dup
db = nil

def eval(sample)
  if $skip_extensions.include? sample[:extname]
    return nil
  end

  # If --all is set, use all languages. Otherwise, get only languages that are
  # ambiguous in terms of filename and extension.
  if $all
    # Empty languages array is the same as all languages.
    languages = []
  else
    languages = Language.find_by_filename(sample[:path]).map(&:name)
    if languages.length == 1
      return nil
    end
    languages = Language.find_by_extension(sample[:path]).map(&:name)
    if languages.length <= 1
      return nil
    end
  end

  # Test only languages with at least 2 samples
  n_samples = 0
  $samples.each do |other_sample|
    if other_sample[:language] == sample[:language]
      n_samples += 1
    end
  end
  if n_samples <= 1
    STDERR.puts "WARNING: No cross-validation possible for #{sample[:language]} (only one sample)"
    return nil
  end

  # Train the classifier.
  db = {}
  db['vocabulary'] = $global_vocab.dup
  db['samples'] = {}
  train_samples = $samples.select { |s| s[:path] != sample[:path] }
  train_samples.each do |train_sample|
    language = train_sample[:language]
    pretrained = train_sample[:pretrained]
    db['samples'][language] ||= []
    db['samples'][language] << pretrained
  end
  Classifier.finalize_train! db

  # Get result.
  results = Classifier.classify(db, sample[:data], languages)
  path = sample[:path].sub("#{Samples::ROOT}/", "")
  if results.length == 0
    "#{path} BAD (Unknown)"
  elsif sample[:language] == results.first[0]
    "#{path} GOOD"
  else
    "#{path} BAD (#{results.first[0]})"
  end
end

results = Parallel.map($samples) { |sample| eval(sample) }
results.reject! { |s| s.nil? }
results.sort!
results.each do |res|
  puts res
end
